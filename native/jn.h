#include <assert.h>
/* expect int32_t, uintptr_t, INT32_MAX ...*/
#include <stdint.h>
#include <string.h>

#include <jni.h>
/* Header for class ss_Jn */

#ifndef _Included_ss_Jn
#define _Included_ss_Jn

//#if !defined(UNUSED)
#if defined(__GNUC__)
#define _UNUSED(x) x __attribute__((unused))
#elif defined(__LCLINT__)
#define _UNUSED(x) /*@unused@*/ x
#endif
#define UNUSED(x) (void)(x)  /* This works on any compiler*/
//#endif /* !defined(UNUSED) */

#ifdef __cplusplus
# define STATIC_CAST(T, x) static_cast<T>(x)
# define REINTERPRET_CAST(T, x) reinterpret_cast<T>(x)
# define CONST_CAST(T, x) const_cast<T>(x)
#else
# define STATIC_CAST(T, x) ((T)(x))
# define REINTERPRET_CAST(T, x) ((T)(x))
# define CONST_CAST(T, x) ((T)(x))
#endif

#ifndef __GNUC__
#define __builtin_expect(x, expected_value) (x)
#endif
#define LIKELY(x)    __builtin_expect(!!(x),1)
#define UNLIKELY(x)  __builtin_expect((x)!=0,0)

#define NOOP (void)0
#define GET_MACRO2(_1, _2, NAME,...) NAME

#ifdef NDEBUG
# define assert(...) NOOP
#define D_PRINT NOOP
#else
# include <assert.h>
// #define assert(condition) /*implementation defined*/
//void asserts(int expr){ assert(expr); }
//void asserts(int expr, const char* msg){ assert(expr); }
# define ASSERT2(expr, msg) assert(expr)
# define ASSERT1(expr) assert(expr)
# define asserts(...) GET_MACRO2(__VA_ARGS__, ASSERT2, ASSERT1)(__VA_ARGS__)
# define D_PRINT printf
#endif
#define ASSERT_UNSUPPORTED() asserts(0, "unimplemented")
#define ASSERT_UNIMPL() asserts(0, "unimplemented")
#define ASSERT_SHOULD_NEVER_REACH() asserts(0, "should never reach here")

//https://en.wikipedia.org/wiki/Data_structure_alignment#Computing_padding
//Compute an `align`-bytes aligned address for `addr`
#define ALIGN_DOWN(addr, align) ((((intptr_t) (addr))) & ~((align) - 1))
#define ALIGN_UP(addr, align) ((((intptr_t) (addr)) + ((align) - 1)) & ~((align) - 1))

/**
 * naked
 * Use this attribute on the ARM, AVR, C4x and IP2K ports to indicate that the specified
 * function does not need prologue/epilogue sequences generated by the compiler. It is
 * up to the programmer to provide these sequences.
 *
 * @see http://stackoverflow.com/questions/19577809/gcc-inlined-assembly-jmp-address-naked-functions
 * @see https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html#Function-Attributes
 */
#ifdef __GNUC__
#define ATTR_NAKED __attribute__((naked))
#else
#define ATTR_NAKED __declspec(naked)
#endif

#if defined(_MSC_VER)
#define GNU_ATTR(...)
#define ASM(...)
#else
// https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax
//[Type Attributes], [attribute specifier list: names with ‘__’ preceding and following the name]
#define GNU_ATTR(...) __attribute__((__VA_ARGS__))
#define ASM asm
#endif

/* Useful for eliminating compiler warnings, forcedly reinterpret cast */
#define FUNC2PTR(f) ((void*)f)

//[attribute packed broken on mingw32?](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52991)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define HAVE_PRAGMA_PACK
#endif

#define nativetrace(...) //printf

#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     ss_Jn
 * Method:    registerNativeMethodStub
 * Signature: (Ljava/lang/reflect/Method;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_ss_Jn_registerNativeMethodStub(JNIEnv *, jclass, jobject, jclass, jstring,
		jstring);
/*
 * Class:     ss_Jn
 * Method:    init
 * Signature: (Ljava/lang/reflect/Method;)I
 */
JNIEXPORT void JNICALL Java_ss_Jn_init(JNIEnv *, jclass, jobject);

#ifdef HAVE_PRAGMA_PACK
#pragma pack(1) /* Specify packing alignment for structure members as 1 byte boundary*/
#endif

typedef struct CStMeta {
	size_t size;
	jclass cls;
	jmethodID ctor;
	jint len;

	//"IF...L<pfid><pfid>...<pfid><pfid>[<pStMeta><cndims><ccomponent><ilength><pclsmeta>"
	//members="I<pfid>F<pfid>L<pfid><pStMeta>[<pfid><cndims><ccomponent><ilength><pclsmeta>"
	char mem[];
} StMeta;

// https://sourceforge.net/p/predef/wiki/Architectures/
//#ifdef __LP64__ || _LP64
#if defined(__i386__) || defined(_M_IX86)
# define SUPPORT_X86
# define stubthunk stubthunk_x86
# define stubthunk_init stubthunk_x86_init
#elif defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64)
# define SUPPORT_X64
# define stubthunk stubthunk_x64
# define stubthunk_init stubthunk_x64_init
#else
# error Unsupported architecture
#endif

#ifdef SUPPORT_X86

// IA-32
typedef struct GNU_ATTR(__packed__) _stubthunk_x86 {
	struct GNU_ATTR(__packed__) {
		uint8_t mov_eax_imm32;  // B8
		// placeholder: a local hard-code pointer variable but this whole code is dynamically created.
		uint32_t ph_mid;// placeholder
	};

	struct GNU_ATTR(__packed__) {
		// placeholder: relative displacement to eip based on the end address of this structure.
		uint8_t jmp_rel32;// E9
		uint32_t ph_ip_to_dispatch;// placeholder
	};
}stubthunk_x86;

// I worry a bit the complier do unexpectedly
union verify_stubthunk_x86_size_manually {
	char stubthunk_size[10 == sizeof(stubthunk_x86) ? 1 : -1];
};

void stubthunk_x86_init(stubthunk_x86 *stub, jmethodID mid);

#endif // end SUPPORT_X86

#ifdef SUPPORT_X64

// AMD64
// [Register Usage](https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx)
// RAX Volatile Return value register
// RCX, RDX, R8, R9 Volatile First 4 integer parameters
// R10:R11 Volatile Must be preserved as needed by caller; used in syscall/sysret instructions
// R12:R15 Nonvolatile Must be preserved by callee
typedef struct GNU_ATTR(__packed__) _stubthunk_x64 {
	struct GNU_ATTR(__packed__) {
		uint8_t mov_r10_imm64[2];  // 49 BA
		uint64_t ph_mid; // placeholder
	};
	struct GNU_ATTR(__packed__) {
		uint8_t mov_rax_imm64[2];  // 48 B8
		uint64_t ph_dispatch; // placeholder
	};
	uint8_t jmp_rax[2]; // FF E0
	uint8_t pad[2]; //09 00
} stubthunk_x64;

// I worry a bit the complier do unexpectedly
union verify_stubthunk_x64_size_manually {
	char stubthunk_size[24 == sizeof(stubthunk_x64) ? 1 : -1];
};

void stubthunk_x64_init(stubthunk_x64 *stub, jmethodID mid);

#endif // end SUPPORT_X64

#ifdef HAVE_PRAGMA_PACK
#pragma pack() /*restore the default packing alignment(maybe 4 bytes)*/
#endif

void *alloc_code(size_t size);

#ifdef __cplusplus
}
#endif

// time-efficient https://gcc.gnu.org/onlinedocs/gcc/Common-Type-Attributes.html#Common-Type-Attributes
struct primitivetype {
	char sig;
	unsigned char nt;
	unsigned short size;
};

struct plaintype {
	char sig;
	unsigned char nt;
	unsigned short size;

	StMeta *hmeta;
};

struct objecttype {
	char sig;
	unsigned char nt;
	short pad;

	int size;
	StMeta *hmeta;
};

struct arraytype {
	char sig;
	unsigned char nt;
	unsigned char ndims;
	unsigned char elementsig;

	int size;
	StMeta *hmeta;
};

typedef struct _CallContext{
	unsigned short nargs;
	char retsig;
	unsigned char retnt;
	int stacksize;
	StMeta *hmeta;
	char args[];
}CallContext;

#endif
