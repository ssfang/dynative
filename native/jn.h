#include <assert.h>
 /* expect int32_t, uintptr_t, INT32_MAX ...*/
#include <stdint.h>
#include <string.h>

#include <jni.h>
/* Header for class ss_Jn */

#ifndef _Included_ss_Jn
#define _Included_ss_Jn


//#if !defined(UNUSED)
#if defined(__GNUC__)
#define _UNUSED(x) x __attribute__((unused))
#elif defined(__LCLINT__)
#define _UNUSED(x) /*@unused@*/ x
#endif
#define UNUSED(x) (void)(x)  /* This works on any compiler*/
//#endif /* !defined(UNUSED) */

#ifdef __cplusplus
# define STATIC_CAST(T, x) static_cast<T>(x)
# define REINTERPRET_CAST(T, x) reinterpret_cast<T>(x)
# define CONST_CAST(T, x) const_cast<T>(x)
#else
# define STATIC_CAST(T, x) ((T)(x))
# define REINTERPRET_CAST(T, x) ((T)(x))
# define CONST_CAST(T, x) ((T)(x))
#endif

#ifndef __GNUC__
#define __builtin_expect(x, expected_value) (x)
#endif
#define LIKELY(x)    __builtin_expect(!!(x),1)
#define UNLIKELY(x)  __builtin_expect((x)!=0,0)

//https://en.wikipedia.org/wiki/Data_structure_alignment#Computing_padding
//Compute an `align`-bytes aligned address for `addr`
#define ALIGN_DOWN(addr, align) ((((intptr_t) (addr))) & ~((align) - 1))
#define ALIGN_UP(addr, align) ((((intptr_t) (addr)) + ((align) - 1)) & ~((align) - 1))


/**
 * naked
 * Use this attribute on the ARM, AVR, C4x and IP2K ports to indicate that the specified
 * function does not need prologue/epilogue sequences generated by the compiler. It is
 * up to the programmer to provide these sequences.
 *
 * @see http://stackoverflow.com/questions/19577809/gcc-inlined-assembly-jmp-address-naked-functions
 * @see https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html#Function-Attributes
 */
#ifdef __GNUC__
#define ATTR_NAKED __attribute__((naked))
#else
#define ATTR_NAKED __declspec(naked)
#endif


#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     ss_Jn
 * Method:    registerNativeMethodStub
 * Signature: (Ljava/lang/reflect/Method;Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_ss_Jn_registerNativeMethodStub(JNIEnv *, jclass, jobject, jclass, jstring,
		jstring, jint argsize);

typedef int *mid_t;

#if !defined(_MSC_VER)
#pragma pack(1) /* Specify packing alignment for structure members as 1 byte boundary*/
#define GNU_ATTR(...)
#else
// https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax
//[Type Attributes], [attribute specifier list: names with ‘__’ preceding and following the name]
#define GNU_ATTR(...) __attribute__((__VA_ARGS__))
#endif

#define st_placeholder(x) 0
//#ifdef __LP64__ || _LP64
#if defined(__i386__)
// IA-32
typedef struct GNU_ATTR(__packed__) _stubthunk_x86 {
	struct GNU_ATTR(__packed__){
		char mov_eax_imm_ptr;  // B8
		// placeholder: a local hard-code pointer variable but this whole code is dynamically created.
		mid_t ph_mid;
	};

	struct GNU_ATTR(__packed__){
		// placeholder: relative displacement to eip based on the end address of this structure.
		char jmp_rel32;         // E9
		int32_t ph_ip_to_dispatch; //
	};
} stubthunk_x86;

const stubthunk_x86 stubthunk_x86_templet = {
	  { 0xB8, st_placeholder(imm_ptr_mid) }  // mov eax, imm_ptr_mid
	, { 0xE9, st_placeholder(rel32_offset) } // jmp rel32_offset
};

extern void stubthunk_interpret_stdcall_x86(void) asm("stubthunk_interpret_stdcall_x86");
#define stubthunk stubthunk_x86
#define stubthunk_templet stubthunk_x86_templet
#define stubthunk_MID_SLOT [ebp-4]
#define STUBTHUNK_SIZE 10
#define stubthunk_init stubthunk_x86_init

inline void stubthunk_x86_init(stubthunk_x86 *stub, mid_t mid) {
	memcpy(stub, &stubthunk_templet, sizeof(stubthunk));
	stub->ph_mid = mid;
	stub->ph_ip_to_dispatch = (int32_t) ((uintptr_t) stubthunk_interpret_stdcall_x86 - ((uintptr_t) stub + sizeof(stubthunk)));
}

#elif defined(__x86_64__)
// AMD64, as to some directives, it will prefix 48 against on x86
typedef struct GNU_ATTR(__packed__) _stubthunk_x64 {
	struct GNU_ATTR(__packed__){
		char mov_rcx_imm64[2];  // 48 B9
		mid_t ph_mid;
	};
	struct GNU_ATTR(__packed__){
		char mov_rax_imm64[2];  // 48 B8
		void* ph_dispatch;
	};
	char jmp_rax[2]; // FF E0
	char pad[2]; //09 00
} stubthunk_x64;

const stubthunk_x64 stubthunk_x64_templet = {
	{ { 0x48, 0xB9 }, st_placeholder(imm_ptr_mid) } //mov imm_ptr_mid, %rcx
	, { { 0x48, 0xB8 }, st_placeholder(imm_ptr_dispatch) } //mov imm_ptr_dispatch, %rax
	, { 0xFF, 0xE0 } //jmp   rax
};

extern void stubthunk_interpret_stdcall_x64(void) asm("stubthunk_interpret_stdcall_x64");
#define stubthunk stubthunk_x64
#define stubthunk_templet stubthunk_x64_templet
#define stubthunk_MID_SLOT rcx
#define STUBTHUNK_SIZE 24

#define stubthunk_init stubthunk_x64_init

inline void stubthunk_x64_init(stubthunk_x64 *stub, mid_t mid) {
	memcpy(stub, &stubthunk_templet, sizeof(stubthunk));
	stub->ph_mid = mid;
	stub->ph_dispatch = stubthunk_interpret_stdcall_x64;
}

#else
# error Unsupported architecture
#endif

#if defined(_MSC_VER)
#pragma pack() /*restore the default packing alignment(maybe 4 bytes)*/
#endif

// I worry a bit the complier do unexpectedly
union verify_stubthunk_size_manually {
	char stubthunk_size[STUBTHUNK_SIZE == sizeof(stubthunk) ? 1 : -STUBTHUNK_SIZE];
};


void *alloc_code(size_t size);

#ifdef __cplusplus
}
#endif
#endif
