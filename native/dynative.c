#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <assert.h>
 /* expect int32_t, uintptr_t, INT32_MAX ...*/
#include <stdint.h>

#ifndef _WIN32
# include <unistd.h>
# include <errno.h>
# include <sys/time.h>
# include <sys/ucontext.h>
/* mmap, mprotect, ...*/
# include <sys/mman.h>
/* [cacheflush](http://man7.org/linux/man-pages/man2/cacheflush.2.html) */
// #include <asm/cachectl.h>

#ifdef	_UNICODE
#define _tprintf wprintf
/*
 * UNICODE a constant string when _UNICODE is defined else returns the string
 * unmodified.  Also defined in w32api/winnt.h.
 */
#define _TEXT(x)	__TEXT(x)
#define	_T(x)		__TEXT(x)
#else
#define _tprintf printf
#define _TEXT(x) x
#define	_T(x) x
#endif

#else
#include <tchar.h>
#include <windows.h>
# endif

//#if !defined(UNUSED)
#if defined(__GNUC__)
#define _UNUSED(x) x __attribute__((unused))
#elif defined(__LCLINT__)
#define _UNUSED(x) /*@unused@*/ x
#endif
#define UNUSED(x) (void)(x)  /* This works on any compiler*/
//#endif /* !defined(UNUSED) */

#ifdef __cplusplus
# define STATIC_CAST(T, x) static_cast<T>(x)
# define REINTERPRET_CAST(T, x) reinterpret_cast<T>(x)
# define CONST_CAST(T, x) const_cast<T>(x)
#else
# define STATIC_CAST(T, x) ((T)(x))
# define REINTERPRET_CAST(T, x) ((T)(x))
# define CONST_CAST(T, x) ((T)(x))
#endif

#ifndef __GNUC__
#define __builtin_expect(x, expected_value) (x)
#endif
#define LIKELY(x)    __builtin_expect(!!(x),1)
#define UNLIKELY(x)  __builtin_expect((x)!=0,0)

#ifdef __cplusplus
}
#endif

//https://en.wikipedia.org/wiki/Data_structure_alignment#Computing_padding
//Compute an `align`-bytes aligned address for `addr`
#define ALIGN_DOWN(addr, align) ((((intptr_t) (addr))) & ~((align) - 1))
#define ALIGN_UP(addr, align) ((((intptr_t) (addr)) + ((align) - 1)) & ~((align) - 1))

/**
 * naked
 * Use this attribute on the ARM, AVR, C4x and IP2K ports to indicate that the specified
 * function does not need prologue/epilogue sequences generated by the compiler. It is
 * up to the programmer to provide these sequences.
 *
 * @see http://stackoverflow.com/questions/19577809/gcc-inlined-assembly-jmp-address-naked-functions
 * @see https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html#Function-Attributes
 */
#ifdef __GNUC__
#define ATTR_NAKED __attribute__((naked))
#else
#define ATTR_NAKED __declspec(naked)
#endif


void dispatch(size_t argsize) {
	//int argsize;
	_tprintf(_T("------dispatch, %d\n"), (int)argsize);
}

typedef int *mid_t;

// short data = DIRECTIVE2(89, E5) ==> short data = (char[]){0x89, 0xE5};
#define DIRECTIVE2(a, b) (char[]){0x##a, 0x##b}

#define TYPEDEF_TYPE_BYTES(NAME, TYPE) typedef union{\
		char bytes[sizeof(TYPE)];\
		TYPE data;\
	}NAME

//directive2
TYPEDEF_TYPE_BYTES(directive2, uint16_t);

#if !defined(_MSC_VER)
#pragma pack(1) /* Specify packing alignment for structure members as 1 byte boundary*/
#define GNU_ATTR(...)
#else
// https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax
//[Type Attributes], [attribute specifier list: names with ‘__’ preceding and following the name]
#define GNU_ATTR(...) __attribute__((__VA_ARGS__))
#endif

#define st_placeholder(x) 0
//#ifdef __LP64__ || _LP64
#if defined(__i386__)
// IA-32
typedef struct GNU_ATTR(__packed__) _stubthunk_x86 {
	struct GNU_ATTR(__packed__){
		char mov_eax_imm_ptr;  // B8
		// placeholder: a local hard-code pointer variable but this whole code is dynamically created.
		mid_t ph_mid;
	};

	struct GNU_ATTR(__packed__){
		// placeholder: relative displacement to eip based on the end address of this structure.
		char jmp_rel32;         // E9
		int32_t ph_ip_to_dispatch; //
	};
} stubthunk_x86;

const stubthunk_x86 stubthunk_x86_templet = {
	  { 0xB8, st_placeholder(imm_ptr_mid) }  // mov eax, imm_ptr_mid
	, { 0xE9, st_placeholder(rel32_offset) } // jmp rel32_offset
};

extern void stubthunk_interpret_stdcall_x64(void);
#define stubthunk stubthunk_x86
#define stubthunk_templet stubthunk_x86_templet
#define stubthunk_MID_SLOT [ebp-4]
#define STUBTHUNK_SIZE 10
#define stubthunk_init stubthunk_x86_init

void stubthunk_x86_init(stubthunk_x86 *stub, mid_t mid) {
	memcpy(stub, &stubthunk_templet, sizeof(stubthunk));
	stub->ph_mid = mid;
	stub->ph_ip_to_dispatch = (int) ((uintptr_t) dispatch - ((uintptr_t) stub + sizeof(stubthunk)));
}

#elif defined(__x86_64__)
// AMD64, as to some directives, it will prefix 48 against on x86
typedef struct GNU_ATTR(__packed__) _stubthunk_x64 {
	struct GNU_ATTR(__packed__){
		char mov_rcx_imm64[2];  // 48 B9
		mid_t ph_mid;
	};
	struct GNU_ATTR(__packed__){
		char mov_rax_imm64[2];  // 48 B8
		void* ph_dispatch;
	};
	char jmp_rax[2]; // FF E0
	char pad[2]; //09 00
} stubthunk_x64;

const stubthunk_x64 stubthunk_x64_templet = {
	{ { 0x48, 0xB9 }, st_placeholder(imm_ptr_mid) } //mov imm_ptr_mid, %rcx
	, { { 0x48, 0xB8 }, st_placeholder(imm_ptr_dispatch) } //mov imm_ptr_dispatch, %rax
	, { 0xFF, 0xE0 } //jmp   rax
};

extern void stubthunk_interpret_stdcall_x64(void);
#define stubthunk stubthunk_x64
#define stubthunk_templet stubthunk_x64_templet
#define stubthunk_MID_SLOT rcx
#define STUBTHUNK_SIZE 24

#define stubthunk_init stubthunk_x64_init

void stubthunk_x64_init(stubthunk_x64 *stub, mid_t mid) {
	memcpy(stub, &stubthunk_templet, sizeof(stubthunk));
	stub->ph_mid = mid;
	stub->ph_dispatch = stubthunk_interpret_stdcall_x64;
}

#else
# error Unsupported architecture
#endif

#if defined(_MSC_VER)
#pragma pack() /*restore the default packing alignment(maybe 4 bytes)*/
#endif

// I worry a bit the complier do unexpectedly
union verify_stubthunk_size_manually {
	char stubthunk_size[STUBTHUNK_SIZE == sizeof(stubthunk) ? 1 : -STUBTHUNK_SIZE];
};


void stubthunk_write(void *stub, mid_t mid) {
	char *pstub = (char *) stub;

	//push  ebp
	*pstub++ = 0x55;

	//mov   ebp, esp
	*pstub++ = 0x89;
	*pstub++ = 0xE5;

	//sub   esp, imm8_local_size
	*pstub++ = 0x83;
	*pstub++ = 0xEC;
	*pstub++ = (char) sizeof(mid_t);

	//mov   [ebp-4], imm_ptr_mid
	*pstub++ = 0xC7;
	*pstub++ = 0x45;
	*pstub++ = 0xFC;
	*(mid_t*) pstub = mid;
	pstub += sizeof(mid_t);

	//jmp   rel16_offset
	*pstub++ = 0xE9;
	*(int*) pstub = (int) ((uintptr_t) dispatch - ((uintptr_t) stub + 18));
}

void stubthunk_call_test(void *stub) {

	// [Inline Assembler Overview](https://msdn.microsoft.com/en-us/library/5f7adz6y.aspx)
#ifdef _MSC_VER
	__asm {
		//MOV  ECX stub  ; prepare the function pointer
		//CALL ECX       ;
		CALL stub;
	}
#else
	__asm__ __volatile(
		"call *%0\n\t" /* the complier will gen like "movl	-16(%ebp), %eax; call %eax", indirect call with `*'*/
		: /* No output registers. */
		:"r" (stub)
		: /* clobbered register.  */
	);
#endif
}

//return NULL if failed.
void *alloc_code(size_t size){
	void *code;
#ifdef _WIN32
	//https://msdn.microsoft.com/en-us/library/windows/desktop/aa366887(v=vs.85).aspx
	code = VirtualAlloc(NULL, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	return code;
#else
	//http://man7.org/linux/man-pages/man2/mmap.2.html
	code = mmap(NULL, size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if(MAP_FAILED != code){
		return code;
	}
	_tprintf(_T("errno(%d):%s\n"), errno, strerror(errno));
	return NULL;
#endif
}

/* allow to run code in memory */
int set_executable(void* addr, size_t size) {
#ifdef _WIN32
	unsigned long old_protect;
	if (VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &old_protect)) {
		// write block from data cache and flush from instruction cache
		//WINBASEAPI BOOL WINAPI FlushInstructionCache(
		// __in HANDLE hProcess,
		// __in_bcount_opt(dwSize) LPCVOID lpBaseAddress,
		// __in SIZE_T dwSize
		//);
		if(FlushInstructionCache(GetCurrentProcess(), addr, size))
			return 0;
	}
	TCHAR szMessageBuffer[128];
	DWORD_PTR dwError = GetLastError();
	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, "GetLastError = %1!x!, %0", dwError,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT), szMessageBuffer, 128, (char**) &dwError);
	//MessageBox(NULL, szMessageBuffer, _T("Error"), MB_OK);
	_tprintf(_T("GetLastError = %u, %s\n"), dwError, szMessageBuffer);
	return -1;
#else
	const int pagesize = sysconf(_SC_PAGE_SIZE);
	_tprintf(_T("pagesize = %d\n"), pagesize);
	/* https://en.wikipedia.org/wiki/Data_structure_alignment#Computing_padding
	 * 	padding = (align - (offset & (align - 1))) & (align - 1) = (-offset) & (align - 1)
	 * 	new offset = (offset + align - 1) & ~(align - 1)
	 */
	intptr_t start, end;
	start = REINTERPRET_CAST(intptr_t, addr) & ~(pagesize - 1); //align down to a page boundary
	end = REINTERPRET_CAST(intptr_t, addr) + size;
	end = (end + pagesize - 1) & ~(pagesize - 1); // align up to a page boundary
	/*
	 * mprotect() changes protection for the calling process's memory page(s) containing any part of
	 * the address range in the interval [addr, addr+len-1].  addr must be aligned to a page boundary.
	 * [mprotect](http://man7.org/linux/man-pages/man2/mprotect.2.html)
	 */
	if(0 == mprotect(REINTERPRET_CAST(void *, start), end - start, PROT_READ | PROT_WRITE | PROT_EXEC)){

	}else{
		_tprintf(_T("errno(%d):%s\n"), errno, strerror(errno));
		return -1;
	}
	/** Well, on windows-x64, I cannot change the memory executable using cygwin gcc on eclipse. */
	extern void __clear_cache(void *beginning, void *end);
	/* http://man7.org/linux/man-pages/man2/cacheflush.2.html */
	//cacheflush(addr, REINTERPRET_CAST(void *, addr) + size, 0);
#ifndef __PCC__
	__clear_cache(addr, REINTERPRET_CAST(void *, addr) + size);
#else
	/* pcc 1.2.0.DEVEL 20141206 don't have such proc */
#endif
#endif
	return 0;
}


/**
 * objcopy --only-keep-debug "${tostripfile.exe}" "${debugfile.pdb}"
 *
 * gcc.exe dynative.c resolve_x64.S -o dynative_cygwin.exe
 * i686-w64-mingw32-gcc.exe dynative.c resolve_x86.S -o dynative_win86.exe
 * x86_64-w64-mingw32-gcc.exe dynative.c resolve_x64.S -o dynative_win64.exe
 **/
int main(int _UNUSED(argc), char *argv[], char *env[]) {
	UNUSED(argv);
	UNUSED(env);

	int retval = 0;
	void *p = (void*)0x1234567890123456;

	_tprintf(_T("sizeof(_stubthunk) = %d, %p\n"), (int) sizeof(stubthunk), p);

	mid_t mid = (mid_t) (argc == 2 ? strtoul(argv[1], NULL, 0) : 123456);

	stubthunk *stub = (stubthunk*)alloc_code(sizeof(stubthunk));
	//stubthunk *stub = (stubthunk *) malloc(sizeof(stubthunk));
	assert(NULL != stub);

	stubthunk_init(stub, mid);

	//retval = set_executable(stub, sizeof(stubthunk));
	//assert(0 == retval);

	if(0 == retval){
		stubthunk_call_test(stub);
	}
	return 0;
}

